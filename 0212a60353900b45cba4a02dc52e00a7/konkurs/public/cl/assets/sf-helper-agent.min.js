/**
 * SaveFrom helper agent
 * @date 17.06.2015
 * @version 1.5
 */
(function sfAddButton() {
  "use strict";
  if (!window.getComputedStyle) {
    return;
  }

  var btnStyle = {
    text: 'Скачать',
    marginTop: 10,
    marginLeft: 5,
    borderWidth: 1
  };

  var undefined = undefined;
  var defVid = 341;
  var cntClassName = 'sf-helper-container';
  var cntInnerClassName = 'sf-helper-container__inner';
  var btnClassName = 'sf-helper-btn';
  var btnTextClassName = 'sf-helper-btn__text';
  var btnArrowClassName = 'sf-helper-btn__arrow';
  var hostingList = {
    youtube: [{host: 'youtube.'},{host: 'youtu.be'}],
    vimeo: [{host: 'vimeo.'}],
    dailymotion: [{host: 'dai.ly'}, {host: 'dailymotion.'}],
    vk: [{host: 'vk.com', url: 'vk.com/video_ext.php'}]
  };

  var hasExtension = function() {
    if (!window.sessionStorage ||
      (window.sessionStorage['savefrom-helper-extension'] === undefined
        && window.sessionStorage['savefrom-helper-userjs'] === undefined)) {
      return false;
    }
    return true;
  };

  var generateUuid = function() {
    if (generateUuid.uuid) {
      return generateUuid.uuid;
    }

    return generateUuid.uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    });
  };

  var trackEvent = function(action, label) {
    var params = {
      v: 1,
      tid: 'UA-7055055-15',
      cid: generateUuid(),
      ec: (api.vid || defVid) + '_' + location.hostname,
      ea: action,
      el: label,
      t: 'event'
    };
    var data = [];
    for (var key in params) {
      data.push(key + '=' + encodeURIComponent(params[key]));
    }
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://www.google-analytics.com/collect?z=' + Date.now(), true);
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
    xhr.send(data.join('&'));
  };

  /**
   * На основании целевого элемента (iframe || embed || object)
   * Проверяем его свойства и если они удовлетворяеют требованиям,
   * генерируем базовые стили для кнопки и ее контейнера
   * @param el {Element}
   * @returns {{elStyle: {}, cStyle: {}, btnStyle: {top: number, left: number}}|undefined}
   */
  var getOptions = function(el) {
    var obj = {};

    // Создаем переменные для сбора необходимый стилей
    // элемента, контейнера кнопки и самой кнопки
    var elStyle = obj.elStyle = {};
    var cStyle = obj.cStyle = {};
    var btnStyle = obj.btnStyle = {
      top: 0,
      left: 0
    };

    // Получили объект с css стилями
    var elStyleList = window.getComputedStyle(el);

    if (elStyleList.getPropertyValue('float') === 'right') {
      return;
    }

    cStyle.display = elStyleList.getPropertyValue('display');

    if (cStyle.display === 'table-cell') {
      cStyle.display = 'block';
    }

    // Если элемент скрыт, выходим из фукнции
    if (cStyle.display === 'none') {
      return;
    }

    var opacity = elStyleList.getPropertyValue('opacity');

    // Если элемент имеет прозрачность 0(не виден) – выходим из функции
    if (parseInt(opacity) === 0) {
      return;
    }

    // Генерируем базовые стили для кнопки
    btnStyle.top += parseInt(elStyleList.getPropertyValue('margin-top')) || 0;
    btnStyle.left += parseInt(elStyleList.getPropertyValue('margin-left')) || 0;
    btnStyle.top += parseInt(elStyleList.getPropertyValue('padding-top')) || 0;
    btnStyle.left += parseInt(elStyleList.getPropertyValue('padding-left')) || 0;

    // Генерируем базовые стили для контейнера кнопки
    cStyle.zIndex = parseInt(elStyleList.getPropertyValue('z-index'));
    if (isNaN(cStyle.zIndex)) {
      cStyle.zIndex = 1;
    } else {
      cStyle.zIndex++;
    }

    cStyle.position = elStyleList.getPropertyValue('position');
    cStyle.width = parseInt(elStyleList.getPropertyValue('width')) || parseInt(el.width) || 0;
    cStyle.height = parseInt(elStyleList.getPropertyValue('height')) || parseInt(el.height) || 0;

    // Если целевой элемент малого размера, менее 100 на 100
    // выходим из фукнции, кнопку не генерим
    if (cStyle.width < 100 || cStyle.height < 100) {
      return;
    }

    // Ширину и высоту контейнера кнопки передаем целевому элементу
    // и удаляем из памяти
    elStyle.width = cStyle.width;
    elStyle.height = cStyle.height;

    cStyle.width = '0px';
    cStyle.height = '0px';

    // Если у элемента родитель тег center, выходим из функции
    if (el.parentNode && el.parentNode.tagName === 'CENTER') {
      return;
      // obj.centerFix = true;
    }

    // Если целевой элемент имеет css позицию absolute или fixed
    // копируем в контейнер теже свойста, чтобы они находились на одном уровне
    if (['absolute', 'fixed'].indexOf(cStyle.position) !== -1) {
      cStyle.left = elStyleList.getPropertyValue('left');
      cStyle.top = elStyleList.getPropertyValue('top');
      cStyle.right = elStyleList.getPropertyValue('right');
      cStyle.bottom = elStyleList.getPropertyValue('bottom');
    }

    for (var item in cStyle) {
      if (!cStyle.hasOwnProperty(item)) {
        continue;
      }

      if (!cStyle[item]) {
        delete cStyle[item];
      }
    }

    return obj;
  };

  // Обработчик mouseover/mouseout на целевом элементе
  // скрывает/показываем кнопку скачать видео
  var videoOver = function(e) {
    var el = this;
    var type = e.type;

    var btn = el.previousSibling.childNodes[0].childNodes[0];

    // на mouseout скрываем кнопку
    if (type === 'mouseout') {
      btn.style.display = 'none';
      return;
    }

    // если не установлен помощник, на mouseover
    // показываем кнопку
    if (el.tagName === 'OBJECT' || !hasExtension()) {
      btn.style.display = 'block';
    }
  };

  var insertButton = function(el, url, options, parent) {
    // Создаем html контейнера кнопки
    var container = document.createElement('div');
    container.classList.add(cntClassName);

    // Наполняем контейнер стилями, собранными ранее
    for (var item in options.cStyle) {
      if (!options.cStyle.hasOwnProperty(item)) {
        continue;
      }
      container.style[item] = options.cStyle[item];
    }

    // Создаем промежуточный html элемент между кнопкой
    // и контейнером, который всегда имеет position: relative
    var btnContainer = document.createElement('div');
    btnContainer.classList.add(cntInnerClassName);
    btnContainer.style.position = 'relative';

    // Создаем саму кнопку
    var button = document.createElement('a');
    var vid = api.vid || defVid;
    button.href = 'http://savefrom.net/youtube-downloader.php?url='+encodeURIComponent(url)+'&vid='+vid;
    button.dataset.savefromGetLinks = url;
    button.classList.add(btnClassName);

    /*if (options.centerFix) {
      btnContainer.style.display = 'inline';
      options.btnStyle.left = 0;
      options.elStyle.width = parseInt(options.elStyle.width / 2);
    }*/

    // Создаем элемента text блока button
    var buttonText = document.createElement('span');
    buttonText.classList.add(btnTextClassName);
    buttonText.textContent = api.text || 'Download';
    buttonText.style.whiteSpace = 'nowrap';
    buttonText.style.verticalAlign = 'middle';

    var buttonArrow = document.createElement('span'),
        buttonArrowStyles = {
          display: 'inline-block',
          verticalAlign: 'middle',
          fontSize: '1.5em',
          marginLeft: '0.3em',
          '-webkit-transform': 'rotate(90deg)',
             '-moz-transform': 'rotate(90deg)',
              '-ms-transform': 'rotate(90deg)',
               '-o-transform': 'rotate(90deg)',
                    transform: 'rotate(90deg)'
        };

    for (var arrowStyle in buttonArrowStyles) {
      if (buttonArrowStyles.hasOwnProperty(arrowStyle)) {
        buttonArrow.style[arrowStyle] = buttonArrowStyles[arrowStyle];
      }
    }

    buttonArrow.classList.add(btnArrowClassName);
    buttonArrow.textContent = '»';

    button.target = '_blank';

    // Дефолтные стили кнопки
    var styleList = {
      paddingLeft: '0.7em',
      paddingRight: '0.7em',
      textAlign: 'center',
      color: 'rgba(255, 255, 255, 0.9)',
      border: '1px solid rgba(255, 255, 255, 0.5)',
      borderWidth: '1px',
      borderRadius: '4px',
      background: 'rgba(0, 0, 0, 0.4)',
      fontFamily: 'Arial, Helvetica, sans-serif',
      fontSize: '12px',
      fontWeight: 'bold',
      lineHeight: '2em',
      textDecoration: 'none',
      position: 'absolute',
      left: '0',
      display: 'inline-block',
      cursor: 'pointer',
      whiteSpace: 'nowrap'
    };

    // Вставляем дефолтные стили для кнопки в атрибут style
    for (var style in styleList) {
      button.style[style] = styleList[style];
    }

    // Если через апи добавили опций, тогда перебираем их
    // и складываем в переменную btnStyle
    if (api.styles && typeof api.styles === "object") {
      for (var prop in api.styles) {
        if (api.styles.hasOwnProperty(prop)) {
          button.style[prop] = api.styles[prop];
        }
      }
    }

    // Делаем кнопку 100% прозрачной
    button.style.opacity = 0;

    button.appendChild(buttonText);
    button.appendChild(buttonArrow);
    // Вставляем в пром.контейнер -> кнопку
    btnContainer.appendChild(button);
    // В контейнер -> пром.контейнер
    container.appendChild(btnContainer);
    // В родителя целевого элемента перед
    // самим элементом вставляем кнопку
    parent.insertBefore(container, el);


    btnStyle.width = button.offsetWidth || btnStyle.width;

    // В зависимости от видео сервиса задаем top и left для кнопки
    if (options.type === 'youtube') {
      options.btnStyle.top += 25;
      options.btnStyle.left += options.elStyle.width - btnStyle.marginLeft*2 - btnStyle.borderWidth*2 - btnStyle.width;
    }
    if (options.type === 'vk') {
      options.btnStyle.left += options.elStyle.width - btnStyle.marginLeft*2 - btnStyle.borderWidth*2 - btnStyle.width;
    }

    button.style.marginTop = (btnStyle.marginTop + options.btnStyle.top)+'px';
    button.style.marginLeft = (btnStyle.marginLeft + options.btnStyle.left) + 'px';
    
    button.style.opacity = 1;

    /**
     * Удаляем подписку, если ранее делали это на mouseover/mouseout
     * по целевому элементу для скрытия/показа кнопки
     */

    // Хак для предотвращения "мигания" кнопки,
    // когда наводим на кнопку мы уходим с целевого элемента
    // и срабатываем mouseout на нем и кнопка показывает/скрывается
    button.addEventListener('mouseover', function() {
      this.style.display = 'block';
    });

    el.removeEventListener('mouseover', videoOver);
    el.removeEventListener('mouseout', videoOver);
    el.addEventListener('mouseover', videoOver);
    el.addEventListener('mouseout', videoOver);

    if (!trackEvent.onInsert && el.tagName === 'IFRAME') {
      trackEvent.onInsert = 1;
      trackEvent('visitors', 'without_helper');
    }
  };

  /**
   * Проверяет полученную параметром ссылку,
   * что она относится к одному из поддерживаемых
   * видео сервису
   * @param url {String} - ссылка на видео сервис
   * @returns {String|undefined}
   */
  var urlCheck = function(url) {
    if (!url) {
      return;
    }

    url = url.toLowerCase();
    var host = url.match(urlCheck.rHostname);

    if (!host) {
      return;
    }
    host = host[1];

    for (var type in hostingList) {

      if (!hostingList.hasOwnProperty(type)) {
        continue;
      }

      for (var i = 0, item; item = hostingList[type][i]; i++) {
        if (host.indexOf(item.host) !== -1) {
          if (!item.url) {
            return type;
          }
          if (url.indexOf(item.url) !== -1) {
            return type;
          }
        }
      }
    }
  };
  urlCheck.rHostname = /:\/\/(?:[^@\/?#]+@)?([^\/?:#]+)/;

  /**
   * Проверяем стили целевого элемента и урл видео сервиса,
   * если оба парамента удовлетворяют требования, вызывает
   * функцию для вставки кнопки в DOM
   * @param el {Element} - DOM node целевого элемента
   * @param hasExt (undefined|boolean)
   */
  var checkEl = function(el, hasExt) {
    var url = el.src; // урл embed || iframe
    var parent = el.parentNode; // родитель -> родительская нода

    /**
     * Если родитель тег object, тогда целевым элементом становится
     * не embed || iframe, а этот object,
     * а родителем, тогда родитель object
     */
    if (parent.tagName === 'OBJECT') {
      el = parent;
      parent = parent.parentNode;
    }

    // Ищем элемент на одном уровне, но перед целевым элементом
    var btnContainer = el.previousSibling;

    // Если уже есть кнопка, выходим из функции run
    if (btnContainer && btnContainer.nodeType === 1 && btnContainer.classList.contains(cntClassName)) {
      return;
    }

    /**
     * Кладем в переменную buttonType знание о том, относится ли урл iframe || embed
     * к поддерживаемым видео сервисом
     */
    var buttonType = urlCheck(url);

    // Если сервис не поддерживается, выходим из функции
    if (!buttonType || !parent) {
      return;
    }

    if (hasExt) {
      if (!trackEvent.onHasExtension) {
        trackEvent.onHasExtension = 1;
        trackEvent('visitors', 'with_helper');
      }
      return;
    }

    // Получаем объект с базовыми стилями
    var options = getOptions(el);

    if (options === undefined) {
      return;
    }

    // Кладем в опции тип кнопки по найденному сервису (youtube, vimeo, etc)
    options.type = buttonType;

    // Вставляем кнопку в DOM
    insertButton(el, url, options, parent);
  };

  /**
   * 1. Если установлен savefrom помощник: находит все embed и
   * вызывает функцию checkEl для каждого, передавая аргументом
   * найденный embed
   * 2. Если не установлен помощник: то помимо 1 шага, делает
   * теже операции со всеми найденными iframe
   */
  var run = function() {
    clearTimeout(run.runTimer);
    run.runTimer = setTimeout(function() {
      var i = 0, len = 0, hasExt = hasExtension();

      var iFrameList = document.getElementsByTagName('iframe');

      for (i = 0, len = iFrameList.length; i < len; i++) {
        checkEl(iFrameList[i], hasExt);
      }

      var embedList = document.getElementsByTagName('embed');
      for (i = 0, len = embedList.length; i < len; i++) {
        checkEl(embedList[i]);
      }
    }, 1000);
  };

  /**
   * Функция запуска скрипта,
   * на первый инит отписывается от событий
   * Также запускает 2 функции:
   * - run -> находит видео на странице, генерит необходимы html, вставляет кнопку, рук-дит ее отображением
   * - monitor -> Создает на каждую кнопку инстанс ObserverMutate и на изменения в доме
   */
  var complete = function() {
    document.removeEventListener("DOMContentLoaded", complete, false);
    window.removeEventListener("load", complete, false);

    run();
    monitor();
  };

  /**
   * Если браузер поддерживает js API MutationObserver
   * Включаем наблюдателя и ждем добавлений новых нод в DOM дереве
   * Если что-то добавилось, перезапускаем скрипт для вставки кнопки
   * p.s. Нужно для случаев, когда видео запускает в модальном окне,
   * которого не было на момент domReady
   */
  var monitor = function() {

    // Если пользователь через API не активировал наблюдатель – выходим
    //if (!api.enableObserver) {
    //  return;
    //}

    // Предотвращаем повторное включение наблюдателя
    if (monitor.enable === 1) {
      return;
    }

    monitor.enable = 1;

    // Если браузер не поддержимае javascript API MutationObserver выходим
    // p.s. http://caniuse.com/#search=MutationObserver
    if (typeof MutationObserver === 'undefined') {
      return;
    }

    var target = document.body;

    var observer = new MutationObserver(function(mutations) {
      var needRun = 0;

      // Перебираем изменения внутри body
      for (var i = 0, mutation; mutation = mutations[i]; i++) {

        // Если в DOM новых нод не добавилось при изменении, идем дальше
        if (mutation.addedNodes.length === 0) {
          continue;
        }

        // В DOM что-то вставили нужно перезапустить скрипт для отрисовки новой кнопки
        needRun = 1;
        break;
      }

      if (needRun === 1) {
        run();
      }

    });

    var config = { childList: true, subtree: true };

    observer.observe(target, config);
  };

  /**
   * Функция, которая принимает пачку параметров
   * для изменения стилей и текста кнопки
   * @param params {Object} принимает любые поля,
   * которые могут понимает метод getComputedStyle
   */
  var api = function(params) {

    if (!params) {
      return;
    }

    if (params.update) {
      run();
    }
  };

  if (typeof window.sfButton === "function") {
    for (var i in window.sfButton) {
      if (!window.sfButton.hasOwnProperty(i)) {
        continue;
      }

      api[i] = window.sfButton[i];
    }
  }

  window.sfButton = api;

  // Предотвращаем повторную инициализацию API
  if (window.sfButton.inited === 1) {
    return;
  }

  api.inited = 1;

  /**
   * Если документ загружен, тогда сразу запускаем скрипт,
   * если нет, тогда подписываемся на события:
   * - загрузку документа
   * - или всего window
   * и только тогда запускаем документ.
   * Это нужно, чтобы к моменту начала работы скрипта,
   * все iframe, embed элементы уже были на странице
   */
  if (document.readyState === 'complete') {
    complete();
  } else {
    document.addEventListener('DOMContentLoaded', complete, false);
    window.addEventListener('load', complete, false);
  }
})();